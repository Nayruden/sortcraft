package net.bulksorter;

import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.command.v2.CommandRegistrationCallback;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ChestBlock;
import net.minecraft.block.SignBlock;
import net.minecraft.block.WallSignBlock;
import net.minecraft.block.ShulkerBoxBlock;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.block.entity.ChestBlockEntity;
import net.minecraft.block.entity.SignBlockEntity;
import net.minecraft.block.enums.ChestType;
import net.minecraft.command.CommandRegistryAccess;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.decoration.ArmorStandEntity;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.registry.Registries;
import net.minecraft.registry.tag.ItemTags;
import net.minecraft.server.command.CommandManager;
import net.minecraft.server.command.ServerCommandSource;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.state.property.Properties;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.inventory.Inventory;
import net.minecraft.component.DataComponentTypes;
import net.minecraft.component.type.ContainerComponent;
import net.minecraft.component.type.BundleContentsComponent;
import net.minecraft.util.collection.DefaultedList;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.WorldChunk;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.DumperOptions;
import java.util.*;
import java.nio.file.Files;
import java.nio.file.Path;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import static net.minecraft.server.command.CommandManager.literal;
import static net.minecraft.server.command.CommandManager.argument;
import net.minecraft.command.argument.ItemStackArgumentType;
import net.minecraft.command.argument.ItemStackArgument;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;


public class BulkSorter implements ModInitializer {
    public static final String MODID = "bulksorter";
    private static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(MODID);
    private static Map<String, Set<Identifier>> categoryItems = new HashMap<>();
    private static Map<Identifier, String> itemCategoryMap = new HashMap<>();

    @Override
    public void onInitialize() {
        loadCategoriesConfig();
        CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
            registerSortCommand(dispatcher);
        });
    }

    private void loadCategoriesConfig() {
        Path configPath = FabricLoader.getInstance().getConfigDir().resolve("sorter").resolve("categories.yaml");
        try {
            if (!Files.exists(configPath)) {
                Files.createDirectories(configPath.getParent());
                String example = "# Example categories configuration\n"
                               + "example_category:\n"
                               + "- minecraft:iron_ingot\n"
                               + "- minecraft:gold_ingot\n";
                Files.write(configPath, example.getBytes(StandardCharsets.UTF_8));
                LOGGER.warn("Category config not found, created example at {}", configPath);
            }
            Yaml yaml = new Yaml();
            try (InputStream in = Files.newInputStream(configPath)) {
                Object data = yaml.load(in);
                if (!(data instanceof Map)){
                    LOGGER.warn("Categories config is not a map, no categories loaded");
                    return;
                }
                @SuppressWarnings("unchecked")
                Map<String, Object> map = (Map<String, Object>) data;
                for (Map.Entry<String, Object> entry : map.entrySet()) {
                    String category = entry.getKey();
                    Object value = entry.getValue();
                    if (!(value instanceof List)) {
                        LOGGER.warn("Category '{}' has a non-list value in YAML, skipping", category);
                        continue;
                    }
                    @SuppressWarnings("unchecked")
                    List<Object> list = (List<Object>) value;
                    Set<Identifier> idSet = new HashSet<>();
                    for (Object obj : list) {
                        if (obj == null) continue;
                        String itemIdStr = obj.toString();
                        try {
                            Identifier id = Identifier.tryParse(itemIdStr);
                            if (id != null) {
                                idSet.add(id);
                                itemCategoryMap.put(id, category);
                            } else {
                                LOGGER.warn("Invalid item identifier '{}' in category '{}'", itemIdStr, category);
                            }
                        } catch (Exception e) {
                            LOGGER.warn("Invalid item identifier '{}' in category '{}'", itemIdStr, category);
                        }
                    }
                    categoryItems.put(category, idSet);
                }
            }
            LOGGER.info("Loaded {} categories from config", categoryItems.size());
        } catch (IOException e) {
            LOGGER.error("Failed to load categories.yaml: {}", e.getMessage());
        }
    }

    private void registerSortCommand(CommandDispatcher<ServerCommandSource> dispatcher) {
        dispatcher.register(
            CommandManager.literal("sort")
                .then(CommandManager.literal("input")
                    .executes(ctx -> executeSortInput(ctx, false)))
                .then(CommandManager.literal("preview")
                    .executes(ctx -> executeSortInput(ctx, true)))
                .then(CommandManager.literal("diagnostics")
                    .executes(this::executeSortDiag))
                .then(CommandManager.literal("whereis")
                    .then(CommandManager.argument("item", StringArgumentType.greedyString())
                        .suggests((context, builder) -> {
                            // Provide suggestions based on available item registry
                            for (Identifier id : Registries.ITEM.getIds()) {
                                builder.suggest(id.toString());
                            }
                            return builder.buildFuture();
                        })
                        .executes(ctx -> executeSortWhereIs(ctx))))
                .then(CommandManager.literal("category")
                    .then(CommandManager.argument("item", StringArgumentType.greedyString())
                        .suggests((context, builder) -> {
                            for (Identifier id : Registries.ITEM.getIds()) {
                                builder.suggest(id.toString());
                            }
                            return builder.buildFuture();
                        })
                        .executes(ctx -> executeSortCategory(ctx))))
                .then(CommandManager.literal("help")
                    .executes(this::executeSortHelp))
        );
    }

    private int executeSortHelp(CommandContext<ServerCommandSource> context) {
        String helpMessage = """
            Sort Command Help:
            /sort input         - Sorts items from the nearby [input] chest
            /sort preview       - Shows a preview of what will be sorted and where
            /sort diagnostics   - Generates a diagnostics report as YAML
            /sort whereis <item> - Finds chests that contain the specified item
            /sort category <item> - Shows the sorting category for the specified item
            /sort help          - Shows this help message
            
            All commands support autocomplete. Use TAB for suggestions.
            """;
        context.getSource().sendFeedback(() -> Text.literal(helpMessage), false);
        return 1;
    }

    private String findTextOnSign(SignBlockEntity sign, String text) {
        return findTextOnSign(sign, text, false);
    }

    // Checks if sign has text and returns the line if so
    private String findTextOnSign(SignBlockEntity sign, String text, boolean isRegex) {
        Text[] lines = sign.getFrontText().getMessages(false);
        for (Text line : lines) {
            if (line == null) continue;

            String line_text = line.getString().trim().toLowerCase();
            if (!isRegex) {
                if (line_text.contains(text)) return line_text;
            } else {
                if (line_text.matches(text)) return line_text;
            }
        }

        return null;
    }

    private SignBlockEntity findClosestSignWithText(ServerWorld world, BlockPos startingPos, String text, int search_distance) {
        double closestDistSq = Double.MAX_VALUE;
        SignBlockEntity closestSign = null;
        int radius = 20;
        BlockPos min = startingPos.add(-radius, -radius, -radius);
        BlockPos max = startingPos.add(radius, radius, radius);

        for (BlockPos pos : BlockPos.iterate(min, max)) {
            BlockEntity be = world.getBlockEntity(pos);
            BlockState state = world.getBlockState(pos);
            if (!(state.getBlock() instanceof WallSignBlock)) continue;
            if (!(be instanceof SignBlockEntity sign)) continue;

            String line = findTextOnSign(sign, text);
            if (line == null) continue;

            LOGGER.info("[findClosestSignWithText] Found possible matching sign at {} with text '{}'", pos, line);
            double distSq = pos.getSquaredDistance(startingPos.toCenterPos());
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                closestSign = sign;
            }
        }

        return closestSign;
    }

    private SortingResults sortStacks(ServerWorld world, 
            BlockPos inputPos,
            Iterable<ItemStack> stacks,
            boolean preview) {

        SortingResults sortingResults = new SortingResults(); 
        for (ItemStack stack: stacks) {
            if (stack.isEmpty()) continue;

            LOGGER.info("[sortinput] Sorting {} of {}", stack.getCount(), stack.getItem().toString());

            Iterable<ItemStack> inner_stacks = getStacksIfContainer(stack);
            if (inner_stacks != null) {
                LOGGER.info("[sortinput] Item is a container. Sorting contents of container.");
                SortingResults innerSortingResults = sortStacks(world, inputPos, inner_stacks, preview);
                sortingResults.sorted += innerSortingResults.sorted;
                sortingResults.overflowCategories.addAll(innerSortingResults.overflowCategories);
                sortingResults.unknownItems.addAll(innerSortingResults.unknownItems);
                innerSortingResults.categoryCounts.forEach((category, count) -> 
                    sortingResults.categoryCounts.merge(category, count, Integer::sum)
                );

                // Restore leftovers to the container
                if (!preview) {
                    if (isBundle(stack)) {
                        BundleContentsComponent bundle_contents;
                        if (innerSortingResults.leftovers.isEmpty()) bundle_contents = new BundleContentsComponent(List.of());
                        else bundle_contents = new BundleContentsComponent(innerSortingResults.leftovers);
                        stack.set(DataComponentTypes.BUNDLE_CONTENTS, bundle_contents);
                    } else { // Shulker
                        DefaultedList<ItemStack> restored = DefaultedList.ofSize(27, ItemStack.EMPTY);
                        for (int i = 0; i < innerSortingResults.leftovers.size() && i < 27; i++) {
                            restored.set(i, innerSortingResults.leftovers.get(i));
                        }
                        stack.set(DataComponentTypes.CONTAINER, ContainerComponent.fromStacks(restored));
                    }
                }

                if (!(innerSortingResults.leftovers.isEmpty())) {
                    LOGGER.info("[sortinput] Inner container not completely emptied, giving up further sorting.");
                    sortingResults.leftovers.add(stack);
                    continue;
                }
            }

            Identifier itemId = Registries.ITEM.getId(stack.getItem());
            String category = itemCategoryMap.get(itemId);
            if (category == null) {
                LOGGER.info("[sortinput] No category found for item: {}", itemId);
                sortingResults.unknownItems.add(itemId.toString());
                sortingResults.leftovers.add(stack);
                continue;
            }

            List<ChestRef> categoryChests = findCategoryChests(world, inputPos, category);
            if (categoryChests.isEmpty()) {
                LOGGER.info("[sortinput] No chests found for category '{}'", category);
                sortingResults.overflowCategories.add(category);
                sortingResults.leftovers.add(stack);
                continue;
            }

            int moved = distributeToChests(stack, categoryChests, preview);
            int stackSize = stack.getCount();
            if (moved > 0) {
                if (!preview) stack.decrement(moved);
                sortingResults.sorted += moved;
                Map<String, Integer> counts = sortingResults.categoryCounts;
                counts.put(category, counts.getOrDefault(category, 0) + moved);
                LOGGER.info("[sortinput] Moved {} of item {}", moved, itemId);
            } 

            if (moved < stackSize) {
                LOGGER.warn("[sortinput] Overflow: Could not store item {} in category '{}'", itemId, category);
                sortingResults.overflowCategories.add(category);
                sortingResults.leftovers.add(stack);
            }
        }
        return sortingResults;
    }

    private int executeSortInput(CommandContext<ServerCommandSource> context, boolean preview) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        ServerWorld world = source.getWorld();
        BlockPos playerPos = source.getPlayer().getBlockPos();
        LOGGER.info("[sortinput] Starting sort near {}", playerPos);

        SignBlockEntity inputSign = findClosestSignWithText(world, playerPos, "[input]", 20);

        if (inputSign == null) {
            source.sendFeedback(() -> Text.literal("No input sign found nearby."), false);
            LOGGER.warn("[sortinput] No input sign found within search radius.");
            return 0;
        }

        BlockPos chestPos = getAttachedChestPos(inputSign.getPos(), inputSign.getCachedState(), world);
        LOGGER.info("[sortinput] Attached chest position resolved: {}", chestPos);

        if (chestPos == null) {
            source.sendFeedback(() -> Text.literal("Input sign isn't attached to a chest."), false);
            LOGGER.warn("[sortinput] Sign at {} is not attached to a chest.", inputSign.getPos());
            return 0;
        }

        BlockState state = world.getBlockState(chestPos);
        if (!(state.getBlock() instanceof ChestBlock chestBlock)) {
            source.sendFeedback(() -> Text.literal("Block attached to the input sign is not a chest."), false);
            LOGGER.warn("[sortinput] Block at {} is not a ChestBlock.", chestPos);
            return 0;
        }

        Inventory inputInv = ChestBlock.getInventory(chestBlock, state, world, chestPos, true);
        if (inputInv == null) {
            source.sendFeedback(() -> Text.literal("Could not access input chest inventory."), false);
            LOGGER.warn("[sortinput] Failed to access chest inventory at {}", chestPos);
            return 0;
        }

        LOGGER.info("[sortinput] Input chest inventory loaded. Beginning sort.");

        SortingResults results = sortStacks(world, chestPos, inputInv, preview);

        for (String cat : results.overflowCategories) {
            source.sendFeedback(() -> Text.literal("⚠ Storage overflow in category: " + cat), false);
        }

        for (String itemId : results.unknownItems) {
            source.sendFeedback(() -> Text.literal("⚠ No category found for item: " + itemId), false);
        }        

        if (preview) {
            Map<String, Integer> counts = results.categoryCounts;
            if (counts.isEmpty()) {
                source.sendFeedback(() -> Text.literal("No items to sort."), false);
            } else {
                source.sendFeedback(() -> Text.literal("Sort Preview:"), false);
                for (Map.Entry<String, Integer> entry : counts.entrySet()) {
                    String cat = entry.getKey();
                    int count = entry.getValue();
                    source.sendFeedback(() -> Text.literal("- " + cat + ": " + count + " item" + (count != 1 ? "s" : "")), false);
                }
            }
            return 1;
        }

        if (results.sorted > 0) {
            world.spawnParticles(ParticleTypes.HAPPY_VILLAGER,
                    chestPos.getX() + 0.5,
                    chestPos.getY() + 1.0,
                    chestPos.getZ() + 0.5,
                    10, 0.4, 0.5, 0.4, 0.1);
            String totalSortedStr = Integer.toString(results.sorted);
            source.sendFeedback(() -> Text.literal(totalSortedStr + " items sorted successfully."), false);
            LOGGER.info("[sortinput] Sorting complete. {} total items sorted. Particles triggered.", totalSortedStr);
        } else {
            source.sendFeedback(() -> Text.literal("No items were sorted."), false);
            LOGGER.info("[sortinput] No items were sorted.");
        }

        return 1;
    }

    private int executeSortWhereIs(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        String itemName = StringArgumentType.getString(context, "item");

        Identifier itemId = Identifier.tryParse(itemName);
        if (itemId == null || !Registries.ITEM.containsId(itemId)) {
            source.sendError(Text.literal("Unknown item: " + itemName));
            return 0;
        }

        Item item = Registries.ITEM.get(itemId);
        ServerWorld world = source.getWorld();
        Set<String> seenPositions = new HashSet<>();
        List<String> foundLocations = new ArrayList<>();

        for (Map.Entry<String, Set<Identifier>> entry : categoryItems.entrySet()) {
            String category = entry.getKey();
            Set<Identifier> items = entry.getValue();

            if (!items.contains(itemId)) continue;

            List<ChestRef> chests = findCategoryChests(world, source.getPlayer().getBlockPos(), category);
            for (ChestRef ref : chests) {
                Inventory inv = ref.inventory;
                for (int slot = 0; slot < inv.size(); slot++) {
                    ItemStack stack = inv.getStack(slot);
                    if (stack.getItem() == item) {
                        String key = ref.pos.toShortString();
                        if (seenPositions.add(key)) {
                            foundLocations.add(key);

                            // Visual effect
                            double x = ref.pos.getX() + 0.5;
                            double y = ref.pos.getY() + 1.0;
                            double z = ref.pos.getZ() + 0.5;
                            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

                            for (int i = 0; i < 10 * 20; i += 2) { // 10 seconds, every 2 ticks
                                long delayMillis = i * 50L; // convert ticks to milliseconds
                                scheduler.schedule(() -> {
                                    world.spawnParticles(ParticleTypes.HAPPY_VILLAGER, x, y, z, 10, 0.5, 0.5, 0.5, 0.05);
                                }, delayMillis, TimeUnit.MILLISECONDS);
                            }
                        }
                        break;
                    }
                }
            }
        }

        if (foundLocations.isEmpty()) {
            source.sendFeedback(() -> Text.literal("No " + itemName + " found in storage chests."), false);
        } else {
            source.sendFeedback(() -> Text.literal("Item '" + itemName + "' found in:"), false);
            for (String loc : foundLocations) {
                source.sendFeedback(() -> Text.literal("- " + loc), false);
            }
        }
        return 1;
    }

    private int executeSortCategory(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        String itemName = StringArgumentType.getString(context, "item");

        Identifier id = Identifier.tryParse(itemName);
        if (id == null || !Registries.ITEM.containsId(id)) {
            source.sendError(Text.literal("Unknown item: " + itemName));
            return 0;
        }
        String category = itemCategoryMap.get(id);
        if (category != null) {
            source.sendFeedback(() -> Text.literal("Item " + id + " belongs to category '" + category + "'."), false);
        } else {
            source.sendFeedback(() -> Text.literal("Item " + id + " is not assigned to any category."), false);
        }
        return 1;
    }

    private int executeSortDiag(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        ServerWorld world = source.getWorld();
        Map<String, Map<String, Object>> categoryData = new TreeMap<>();

        for (Map.Entry<String, Set<Identifier>> entry : categoryItems.entrySet()) {
            String category = entry.getKey();
            Set<Identifier> items = entry.getValue();

            List<ChestRef> chests = findCategoryChests(world, source.getPlayer().getBlockPos(), category);
            if (chests.isEmpty()) continue;

            Map<String, Object> itemData = new TreeMap<>();
            int totalSlots = chests.size() * 27;
            int usedSlots = 0;

            for (Identifier id : items) {
                Item item = Registries.ITEM.get(id);
                if (item == null) continue;

                float total = 0;
                Map<String, Float> locationCounts = new LinkedHashMap<>();

                for (ChestRef ref : chests) {
                    Inventory inv = ref.inventory;
                    float count = 0;
                    for (int slot = 0; slot < inv.size(); slot++) {
                        ItemStack stack = inv.getStack(slot);
                        if (stack.getItem() == item) {
                            count += stack.getCount();
                            if (!inv.getStack(slot).isEmpty()) usedSlots++;
                        }
                    }
                    if (count > 0) {
                        String loc = ref.pos.getX() + " " + ref.pos.getY() + " " + ref.pos.getZ();
                        locationCounts.merge(loc, count, Float::sum);
                        total += count;
                    }
                }

                if (total > 0) {
                    Map<String, Object> itemEntry = new LinkedHashMap<>();
                    itemEntry.put("total_quantity", total);
                    if (!locationCounts.isEmpty()) {
                        List<Map<String, Object>> chestLocations = new ArrayList<>();
                        for (Map.Entry<String, Float> e : locationCounts.entrySet()) {
                            Map<String, Object> loc = new LinkedHashMap<>();
                            loc.put("location", e.getKey());
                            loc.put("quantity", e.getValue());
                            chestLocations.add(loc);
                        }
                        itemEntry.put("chest_locations", chestLocations);
                    }
                    itemData.put(id.toString(), itemEntry);
                }
            }

            if (!itemData.isEmpty()) {
                // Add space_used calculation
                float spaceUsed = (totalSlots > 0) ? ((float) usedSlots / totalSlots) * 100f : 0f;
                itemData.put("space_used", String.format("%.0f%%", spaceUsed));

                categoryData.put(category, itemData);
            }
        }

        Map<String, Object> finalYaml = new LinkedHashMap<>();
        for (Map.Entry<String, Map<String, Object>> e : categoryData.entrySet()) {
            finalYaml.put(e.getKey(), e.getValue());
        }

        try {
            File file = new File(FabricLoader.getInstance().getConfigDir().toFile(), "sorter/sortdiag.yaml");
            file.getParentFile().mkdirs();

            DumperOptions options = new DumperOptions();
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
            options.setPrettyFlow(true);

            Yaml yaml = new Yaml(options);
            try (FileWriter writer = new FileWriter(file)) {
                yaml.dump(finalYaml, writer);
            }
        } catch (IOException e) {
            source.sendError(Text.literal("Failed to write sorter/sortdiag.yaml: " + e.getMessage()));
            return 0;
        }

        source.sendFeedback(() -> Text.literal("Sorter diagnostic written to sorter/sortdiag.yaml"), false);
        return 1;
    }

    private boolean isBundle(ItemStack stack) {
        return stack.getOrDefault(DataComponentTypes.BUNDLE_CONTENTS, null) != null;
    }

    private Iterable<ItemStack> getStacksIfContainer(ItemStack stack) {
        BundleContentsComponent bundle = stack.getOrDefault(DataComponentTypes.BUNDLE_CONTENTS, null);
        if (bundle != null) return bundle.iterate();

        ContainerComponent container = stack.getOrDefault(DataComponentTypes.CONTAINER, null);
        if (container != null) {
            DefaultedList<ItemStack> container_stacks = DefaultedList.ofSize(27, ItemStack.EMPTY);
            container.copyTo(container_stacks);
            return container_stacks;
        }

        return null;
    }

    private int distributeToChests(ItemStack stack, List<ChestRef> chests, boolean preview) {
        int originalCount = stack.getCount();
        int toSort = originalCount;
        int maxStackSize = Math.min(stack.getMaxCount(), 64);

        for (ChestRef ref : chests) {
            Inventory inv = ref.inventory;

            // Merge into existing stacks
            for (int slot = 0; slot < inv.size() && toSort > 0; slot++) {
                ItemStack target = inv.getStack(slot);
                if (!target.isEmpty() && ItemStack.areItemsAndComponentsEqual(stack, target) && target.getCount() < target.getMaxCount()) {
                    int space = target.getMaxCount() - target.getCount();
                    int move = Math.min(space, toSort);
                    if (!preview) target.increment(move);
                    toSort -= move;
                }
            }

            // Fill empty slots
            for (int slot = 0; slot < inv.size() && toSort > 0; slot++) {
                if (inv.getStack(slot).isEmpty()) {
                    int move = Math.min(toSort, maxStackSize);
                    if (!preview) {
                        ItemStack toPut = stack.copy();
                        toPut.setCount(move);
                        inv.setStack(slot, toPut);
                    }
                    toSort -= move;
                }
            }

            if (toSort == 0) break;
        }

        return originalCount - toSort;
    }

    private BlockPos getAttachedChestPos(BlockPos signPos, BlockState signState, ServerWorld world) {
        Direction attachedDirection = signState.get(Properties.HORIZONTAL_FACING, null);

        if (attachedDirection == null) return null;
        attachedDirection = attachedDirection.getOpposite();

        BlockPos chestPos = signPos.offset(attachedDirection);
        BlockEntity be = world.getBlockEntity(chestPos);
        if (be instanceof ChestBlockEntity) {
            return chestPos;
        }
        return null;
    }

    // Helper to return 1 or 2 block positions that make up a single/double chest
    private List<BlockPos> getChestBlocks(BlockPos pos, ServerWorld world) {
        BlockState state = world.getBlockState(pos);
        List<BlockPos> blocks = new ArrayList<>();
        blocks.add(pos);
        ChestType chestType = state.get(Properties.CHEST_TYPE, null);
        Direction facing = state.get(Properties.HORIZONTAL_FACING, null);

        if (chestType == null || facing == null || chestType == ChestType.SINGLE) return blocks;
        if (chestType == ChestType.RIGHT) {
            blocks.add(pos.offset(facing.rotateYCounterclockwise()));
        } else {
            blocks.add(pos.offset(facing.rotateYClockwise()));
        }
        return blocks;
    }

    private List<ChestRef> collectChestStack(ServerWorld world, BlockPos startPos) {
        List<ChestRef> result = new ArrayList<>();
        BlockPos cur = startPos;

        while (true) {
            BlockState state = world.getBlockState(cur);

            Block block = state.getBlock();
            if (block instanceof ChestBlock chestBlock) {
                Inventory inv = ChestBlock.getInventory(chestBlock, state, world, cur, true);
                if (inv != null) {
                    result.add(new ChestRef(cur, inv));
                    LOGGER.info("[cheststack] Added chest at {}", cur);
                }
            }
            //}

            // Check for category sign attached to the next chest *below*
            BlockPos below = cur.down();
            if (!(world.getBlockEntity(below) instanceof ChestBlockEntity)) {
                LOGGER.info("[cheststack] Block below {} is not a chest. Done.", cur);
                break;
            }

            List<BlockPos> blocksForChest = getChestBlocks(below, world);
            for (Direction dir : Direction.Type.HORIZONTAL) {
                for (BlockPos chestPos : blocksForChest) {
                    BlockPos signPos = chestPos.offset(dir);
                    BlockState signState = world.getBlockState(signPos);

                    LOGGER.info("[cheststack] Checking chestPos {} and direction {} - pos {} for a sign.", chestPos, dir, signPos);

                    if (!(signState.getBlock() instanceof WallSignBlock)) continue;
                    // Only proceed if the sign is facing the chest
                    if (!signPos.offset(signState.get(WallSignBlock.FACING).getOpposite()).equals(chestPos)) continue;

                    BlockEntity signBe = world.getBlockEntity(signPos);
                    if (!(signBe instanceof SignBlockEntity sign)) continue;
                    String line = findTextOnSign(sign, "\\[.+?]", true);
                    if (line == null) continue;

                    LOGGER.info("[cheststack] Found category sign at {} - {}. Stopping stack here.", signPos, line);
                    Collections.reverse(result);
                    return result;
                }
            }

            cur = below;
        }

        Collections.reverse(result);
        return result;
    }

    private List<ChestRef> findCategoryChests(ServerWorld world, BlockPos nearPos, String category) {
        LOGGER.info("[findCategoryChests] Searching signs near {} for category '{}'", nearPos, category);

        SignBlockEntity targetSign = findClosestSignWithText(world, nearPos, "[" + category + "]", 64);

        if (targetSign == null) {
            LOGGER.info("[findCategoryChests] No matching sign found for category '{}'", category);
            return Collections.emptyList();
        }

        LOGGER.info("[findCategoryChests] Nearest matching sign is at {}", targetSign.getPos());

        BlockPos chestPos = getAttachedChestPos(targetSign.getPos(), targetSign.getCachedState(), world);
        if (chestPos == null) {
            LOGGER.info("[findCategoryChests] No chest attached to sign at {}", targetSign.getPos());
            return Collections.emptyList();
        }

        LOGGER.info("[findCategoryChests] Resolved chest position: {}", chestPos);

        List<ChestRef> stack = collectChestStack(world, chestPos);
        LOGGER.info("[findCategoryChests] Found {} chest(s) in the stack.", stack.size());

        return stack;
    }

    private static class ChestRef {
        BlockPos pos;
        Inventory inventory;
        ChestRef(BlockPos pos, Inventory inv) {
            this.pos = pos;
            this.inventory = inv;
        }
    }

    private static class SortingResults {
        int sorted = 0;
        Set<String> unknownItems = new HashSet<String>();
        Set<String> overflowCategories = new HashSet<String>();
        List<ItemStack> leftovers = new ArrayList<ItemStack>();
        Map<String, Integer> categoryCounts  = new HashMap<String, Integer>();
    }
}
