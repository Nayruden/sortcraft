package net.bulksorter;

import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.command.v2.CommandRegistrationCallback;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.ChestBlock;
import net.minecraft.block.SignBlock;
import net.minecraft.block.WallSignBlock;
import net.minecraft.block.ShulkerBoxBlock;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.block.entity.ChestBlockEntity;
import net.minecraft.block.entity.SignBlockEntity;
import net.minecraft.block.enums.ChestType;
import net.minecraft.command.CommandRegistryAccess;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.decoration.ArmorStandEntity;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.registry.Registries;
import net.minecraft.registry.tag.ItemTags;
import net.minecraft.server.command.CommandManager;
import net.minecraft.server.command.ServerCommandSource;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.state.property.Properties;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.inventory.Inventory;
import net.minecraft.component.DataComponentTypes;
import net.minecraft.component.type.ContainerComponent;
import net.minecraft.component.type.BundleContentsComponent;
import net.minecraft.util.collection.DefaultedList;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.WorldChunk;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.DumperOptions;
import java.util.*;
import java.nio.file.Files;
import java.nio.file.Path;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import static net.minecraft.server.command.CommandManager.literal;
import static net.minecraft.server.command.CommandManager.argument;
import net.minecraft.command.argument.ItemStackArgumentType;
import net.minecraft.command.argument.ItemStackArgument;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;


public class BulkSorter implements ModInitializer {
    public static final String MODID = "bulksorter";
    //public static final Logger LOGGER = LoggerFactory.getLogger("bulksorter");
    private static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(MODID);
    private static Map<String, Set<Identifier>> categoryItems = new HashMap<>();
    private static Map<Identifier, String> itemCategoryMap = new HashMap<>();
    private static final List<TempMarker> tempMarkers = Collections.synchronizedList(new ArrayList<>());

    @Override
    public void onInitialize() {
        loadCategoriesConfig();
        CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
            registerSortCommand(dispatcher);
        });
        ServerTickEvents.END_SERVER_TICK.register(server -> {
            synchronized (tempMarkers) {
                Iterator<TempMarker> iter = tempMarkers.iterator();
                while (iter.hasNext()) {
                    TempMarker marker = iter.next();
                    marker.ticksLeft--;
                    if (marker.ticksLeft <= 0) {
                        if (!marker.entity.isRemoved()) {
                            marker.entity.discard();
                        }
                        iter.remove();
                    }
                }
            }
        });
    }

    private void loadCategoriesConfig() {
        Path configPath = FabricLoader.getInstance().getConfigDir().resolve("sorter").resolve("categories.yaml");
        try {
            if (!Files.exists(configPath)) {
                Files.createDirectories(configPath.getParent());
                String example = "# Example categories configuration\n"
                               + "example_category:\n"
                               + "  - minecraft:iron_ingot\n"
                               + "  - minecraft:gold_ingot\n";
                Files.write(configPath, example.getBytes(StandardCharsets.UTF_8));
                LOGGER.warn("Category config not found, created example at {}", configPath);
            }
            Yaml yaml = new Yaml();
            try (InputStream in = Files.newInputStream(configPath)) {
                Object data = yaml.load(in);
                if (data instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> map = (Map<String, Object>) data;
                    for (Map.Entry<String, Object> entry : map.entrySet()) {
                        String category = entry.getKey();
                        Object value = entry.getValue();
                        if (value instanceof List) {
                            @SuppressWarnings("unchecked")
                            List<Object> list = (List<Object>) value;
                            Set<Identifier> idSet = new HashSet<>();
                            for (Object obj : list) {
                                if (obj == null) continue;
                                String itemIdStr = obj.toString();
                                try {
                                    Identifier id = Identifier.tryParse(itemIdStr);
                                    if (id != null) {
                                        idSet.add(id);
                                        itemCategoryMap.put(id, category);
                                    } else {
                                        LOGGER.warn("Invalid item identifier '{}' in category '{}'", itemIdStr, category);
                                    }
                                } catch (Exception e) {
                                    LOGGER.warn("Invalid item identifier '{}' in category '{}'", itemIdStr, category);
                                }
                            }
                            categoryItems.put(category, idSet);
                        } else {
                            LOGGER.warn("Category '{}' has a non-list value in YAML, skipping", category);
                        }
                    }
                } else {
                    LOGGER.warn("Categories config is not a map, no categories loaded");
                }
            }
            LOGGER.info("Loaded {} categories from config", categoryItems.size());
        } catch (IOException e) {
            LOGGER.error("Failed to load categories.yaml: {}", e.getMessage());
        }
    }

    private void registerSortCommand(CommandDispatcher<ServerCommandSource> dispatcher) {
        dispatcher.register(
            CommandManager.literal("sort")
                .then(CommandManager.literal("input")
                    .executes(this::executeSortInput))
                .then(CommandManager.literal("preview")
                    .executes(this::executeSortPreview))
                .then(CommandManager.literal("diagnostics")
                    .executes(this::executeSortDiag))
                .then(CommandManager.literal("whereis")
                    .then(CommandManager.argument("item", StringArgumentType.greedyString())
                        .suggests((context, builder) -> {
                            // Provide suggestions based on available item registry
                            for (Identifier id : Registries.ITEM.getIds()) {
                                builder.suggest(id.toString());
                            }
                            return builder.buildFuture();
                        })
                        .executes(ctx -> executeSortWhereIs(ctx))))
                .then(CommandManager.literal("category")
                    .then(CommandManager.argument("item", StringArgumentType.greedyString())
                        .suggests((context, builder) -> {
                            for (Identifier id : Registries.ITEM.getIds()) {
                                builder.suggest(id.toString());
                            }
                            return builder.buildFuture();
                        })
                        .executes(ctx -> executeSortCategory(ctx))))
                .then(CommandManager.literal("help")
                    .executes(this::executeSortHelp))
        );
    }

    private int executeSortHelp(CommandContext<ServerCommandSource> context) {
        String helpMessage = """
            Sort Command Help:
            /sort input         - Sorts items from the nearby [input] chest
            /sort preview       - Shows a preview of what will be sorted and where
            /sort diagnostics   - Generates a diagnostics report as YAML
            /sort whereis <item> - Finds chests that contain the specified item
            /sort category <item> - Shows the sorting category for the specified item
            /sort help          - Shows this help message
            
            All commands support autocomplete. Use TAB for suggestions.
            """;
        context.getSource().sendFeedback(() -> Text.literal(helpMessage), false);
        return 1;
    }

    private int executeSortInput(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        ServerWorld world = source.getWorld();
        BlockPos playerPos = source.getPlayer().getBlockPos();
        LOGGER.info("[sortinput] Starting sort near {}", playerPos);

        SignBlockEntity inputSign = null;
        double nearestDistSq = Double.MAX_VALUE;
        int radius = 20;
        BlockPos min = playerPos.add(-radius, -radius / 2, -radius);
        BlockPos max = playerPos.add(radius, radius / 2, radius);

        for (BlockPos pos : BlockPos.iterate(min, max)) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof SignBlockEntity sign) {
                Text[] lines = sign.getFrontText().getMessages(false);
                for (Text line : lines) {
                    if (line != null) {
                        String text = line.getString().trim().toLowerCase();
                        if (text.contains("[input]")) {
                            double distSq = pos.getSquaredDistance(playerPos.toCenterPos());
                            LOGGER.info("[sortinput] Found possible input sign at {} with text '{}'", pos, text);
                            if (distSq < nearestDistSq) {
                                nearestDistSq = distSq;
                                inputSign = sign;
                            }
                            break;
                        }
                    }
                }
            }
        }

        if (inputSign == null) {
            source.sendFeedback(() -> Text.literal("No input sign found nearby."), false);
            LOGGER.warn("[sortinput] No input sign found within search radius.");
            return 0;
        }

        BlockPos chestPos = getAttachedChestPos(inputSign.getPos(), inputSign.getCachedState(), world);
        LOGGER.info("[sortinput] Attached chest position resolved: {}", chestPos);

        if (chestPos == null) {
            source.sendFeedback(() -> Text.literal("Input sign isn't attached to a chest."), false);
            LOGGER.warn("[sortinput] Sign at {} is not attached to a chest.", inputSign.getPos());
            return 0;
        }

        BlockState state = world.getBlockState(chestPos);
        if (!(state.getBlock() instanceof ChestBlock chestBlock)) {
            source.sendFeedback(() -> Text.literal("Block attached to the input sign is not a chest."), false);
            LOGGER.warn("[sortinput] Block at {} is not a ChestBlock.", chestPos);
            return 0;
        }

        Inventory inputInv = ChestBlock.getInventory(chestBlock, state, world, chestPos, true);
        if (inputInv == null) {
            source.sendFeedback(() -> Text.literal("Could not access input chest inventory."), false);
            LOGGER.warn("[sortinput] Failed to access chest inventory at {}", chestPos);
            return 0;
        }

        LOGGER.info("[sortinput] Input chest inventory loaded. Beginning sort.");

        HashSet<String> overflowCategories = new HashSet<>();
        boolean sortedAny = false;

        for (int slot = 0; slot < inputInv.size(); slot++) {
            ItemStack stack = inputInv.getStack(slot);
            if (stack.isEmpty()) continue;

            LOGGER.info("[sortinput] Slot {}: {}", slot, stack.getItem().toString());

            if (isContainerItem(stack)) {
                LOGGER.info("[sortinput] Item is a container. Sorting contents of container.");
                sortedAny |= sortContainerItem(stack, world, chestPos, overflowCategories);
                continue;
            }

            Identifier itemId = Registries.ITEM.getId(stack.getItem());
            String category = itemCategoryMap.get(itemId);
            if (category == null) {
                LOGGER.info("[sortinput] No category found for item: {}", itemId);
                continue;
            }

            List<ChestRef> categoryChests = findCategoryChests(world, chestPos, category);
            if (categoryChests.isEmpty()) {
                LOGGER.info("[sortinput] No chests found for category '{}'", category);
                overflowCategories.add(category);
                continue;
            }

            int moved = distributeToChests(stack, categoryChests);
            if (moved > 0) {
                stack.decrement(moved);
                sortedAny = true;
                LOGGER.info("[sortinput] Moved {} of item {}", moved, itemId);
            } else {
                overflowCategories.add(category);
                LOGGER.warn("[sortinput] Overflow: Could not store item {} in category '{}'", itemId, category);
            }
        }

        if (sortedAny) {
            world.spawnParticles(ParticleTypes.HAPPY_VILLAGER,
                    chestPos.getX() + 0.5,
                    chestPos.getY() + 1.0,
                    chestPos.getZ() + 0.5,
                    10, 0.4, 0.5, 0.4, 0.1);
            source.sendFeedback(() -> Text.literal("Items sorted successfully."), false);
            LOGGER.info("[sortinput] Sorting complete. Particles triggered.");
        } else {
            source.sendFeedback(() -> Text.literal("No items were sorted."), false);
            LOGGER.info("[sortinput] No items were sorted.");
        }

        if (!overflowCategories.isEmpty()) {
            for (String cat : overflowCategories) {
                source.sendFeedback(() -> Text.literal("⚠ Storage overflow in category: " + cat), false);
            }
        }

        return 1;
    }

    private int executeSortPreview(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        ServerWorld world = source.getWorld();
        Vec3d vec = source.getPosition();
        BlockPos playerPos = new BlockPos((int) vec.x, (int) vec.y, (int) vec.z);
        SignBlockEntity inputSign = null;
        double nearestDistSq = Double.MAX_VALUE;
        int radius = 20;
        BlockPos min = playerPos.add(-radius, -radius / 2, -radius);
        BlockPos max = playerPos.add(radius, radius / 2, radius);

        for (BlockPos pos : BlockPos.iterate(min, max)) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof SignBlockEntity sign) {
                Text[] lines = sign.getFrontText().getMessages(false);
                for (Text line : lines) {
                    if (line != null && !line.getString().trim().isEmpty()) {
                        String text = line.getString().trim();
                        if (text.toLowerCase().contains("[input]")) {
                            double distSq = pos.getSquaredDistance(playerPos);
                            if (distSq < nearestDistSq) {
                                nearestDistSq = distSq;
                                inputSign = sign;
                            }
                            break;
                        }
                    }
                }
            }
        }

        if (inputSign == null) {
            source.sendError(Text.literal("No input chest found nearby."));
            return 0;
        }

        BlockPos chestPos = getAttachedChestPos(inputSign.getPos(), inputSign.getCachedState(), world);
        if (chestPos == null) {
            source.sendError(Text.literal("Invalid input chest sign placement."));
            return 0;
        }

        BlockState state = world.getBlockState(chestPos);
        Block block = state.getBlock();
        if (!(block instanceof ChestBlock chestBlock)) {
            source.sendError(Text.literal("Block at chestPos is not a ChestBlock"));
            return 0;
        }

        Inventory inputInv = ChestBlock.getInventory(chestBlock, state, world, chestPos, true);
        Map<String, Integer> categoryCount = new HashMap<>();

        for (int slot = 0; slot < inputInv.size(); slot++) {
            ItemStack stack = inputInv.getStack(slot);
            if (stack.isEmpty()) continue;
            previewCountRecursive(stack, categoryCount);
        }

        if (categoryCount.isEmpty()) {
            source.sendFeedback(() -> Text.literal("No items to sort."), false);
        } else {
            source.sendFeedback(() -> Text.literal("Sort Preview:"), false);
            for (Map.Entry<String, Integer> entry : categoryCount.entrySet()) {
                String cat = entry.getKey();
                int count = entry.getValue();
                source.sendFeedback(() -> Text.literal("- " + cat + ": " + count + " item" + (count != 1 ? "s" : "")), false);
            }
        }
        return 1;
    }

    private void previewCountRecursive(ItemStack stack, Map<String, Integer> categoryCount) {
        if (stack.isEmpty()) return;

        Identifier id = Registries.ITEM.getId(stack.getItem());
        String category = itemCategoryMap.get(id);
        if (category != null) {
            categoryCount.put(category, categoryCount.getOrDefault(category, 0) + stack.getCount());
        }

        if (isContainerItem(stack)) {
            if (stack.isOf(Items.BUNDLE) && stack.get(DataComponentTypes.BUNDLE_CONTENTS) != null) {
                BundleContentsComponent comp = stack.get(DataComponentTypes.BUNDLE_CONTENTS);
                for (ItemStack inner : comp.iterateCopy()) {
                    previewCountRecursive(inner, categoryCount);
                }
            } else if (stack.get(DataComponentTypes.CONTAINER) != null) {
                ContainerComponent comp = stack.get(DataComponentTypes.CONTAINER);
                DefaultedList<ItemStack> tempList = DefaultedList.ofSize(27, ItemStack.EMPTY);
                comp.copyTo(tempList);
                for (ItemStack inner : tempList) {
                    if (inner != null && !inner.isEmpty()) {
                        previewCountRecursive(inner, categoryCount);
                    }
                }
            }
        }
    }

    private int executeSortWhereIs(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        String itemName = StringArgumentType.getString(context, "item");

        Identifier itemId = Identifier.tryParse(itemName);
        if (itemId == null || !Registries.ITEM.containsId(itemId)) {
            source.sendError(Text.literal("Unknown item: " + itemName));
            return 0;
        }

        Item item = Registries.ITEM.get(itemId);
        ServerWorld world = source.getWorld();
        Set<String> seenPositions = new HashSet<>();
        List<String> foundLocations = new ArrayList<>();

        for (Map.Entry<String, Set<Identifier>> entry : categoryItems.entrySet()) {
            String category = entry.getKey();
            Set<Identifier> items = entry.getValue();

            if (!items.contains(itemId)) continue;

            List<ChestRef> chests = findCategoryChests(world, source.getPlayer().getBlockPos(), category);
            for (ChestRef ref : chests) {
                Inventory inv = ref.inventory;
                for (int slot = 0; slot < inv.size(); slot++) {
                    ItemStack stack = inv.getStack(slot);
                    if (stack.getItem() == item) {
                        String key = ref.pos.toShortString();
                        if (seenPositions.add(key)) {
                            foundLocations.add(key);

                            // Visual effect
                            double x = ref.pos.getX() + 0.5;
                            double y = ref.pos.getY() + 1.0;
                            double z = ref.pos.getZ() + 0.5;
                            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

                            for (int i = 0; i < 10 * 20; i += 2) { // 10 seconds, every 2 ticks
                                long delayMillis = i * 50L; // convert ticks to milliseconds
                                scheduler.schedule(() -> {
                                    world.spawnParticles(ParticleTypes.HAPPY_VILLAGER, x, y, z, 10, 0.5, 0.5, 0.5, 0.05);
                                }, delayMillis, TimeUnit.MILLISECONDS);
                            }
                        }
                        break;
                    }
                }
            }
        }

        if (foundLocations.isEmpty()) {
            source.sendFeedback(() -> Text.literal("No " + itemName + " found in storage chests."), false);
        } else {
            source.sendFeedback(() -> Text.literal("Item '" + itemName + "' found in:"), false);
            for (String loc : foundLocations) {
                source.sendFeedback(() -> Text.literal("- " + loc), false);
            }
        }
        return 1;
    }

    private int executeSortCategory(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        String itemName = StringArgumentType.getString(context, "item");

        Identifier id = Identifier.tryParse(itemName);
        if (id == null || !Registries.ITEM.containsId(id)) {
            source.sendError(Text.literal("Unknown item: " + itemName));
            return 0;
        }
        String category = itemCategoryMap.get(id);
        if (category != null) {
            source.sendFeedback(() -> Text.literal("Item " + id + " belongs to category '" + category + "'."), false);
        } else {
            source.sendFeedback(() -> Text.literal("Item " + id + " is not assigned to any category."), false);
        }
        return 1;
    }

    private int executeSortDiag(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        ServerWorld world = source.getWorld();
        Map<String, Map<String, Object>> categoryData = new TreeMap<>();

        for (Map.Entry<String, Set<Identifier>> entry : categoryItems.entrySet()) {
            String category = entry.getKey();
            Set<Identifier> items = entry.getValue();

            List<ChestRef> chests = findCategoryChests(world, source.getPlayer().getBlockPos(), category);
            if (chests.isEmpty()) continue;

            Map<String, Object> itemData = new TreeMap<>();
            int totalSlots = chests.size() * 27;
            int usedSlots = 0;

            for (Identifier id : items) {
                Item item = Registries.ITEM.get(id);
                if (item == null) continue;

                float total = 0;
                Map<String, Float> locationCounts = new LinkedHashMap<>();

                for (ChestRef ref : chests) {
                    Inventory inv = ref.inventory;
                    float count = 0;
                    for (int slot = 0; slot < inv.size(); slot++) {
                        ItemStack stack = inv.getStack(slot);
                        if (stack.getItem() == item) {
                            count += stack.getCount();
                            if (!inv.getStack(slot).isEmpty()) usedSlots++;
                        }
                    }
                    if (count > 0) {
                        String loc = ref.pos.getX() + " " + ref.pos.getY() + " " + ref.pos.getZ();
                        locationCounts.merge(loc, count, Float::sum);
                        total += count;
                    }
                }

                if (total > 0) {
                    Map<String, Object> itemEntry = new LinkedHashMap<>();
                    itemEntry.put("total_quantity", total);
                    if (!locationCounts.isEmpty()) {
                        List<Map<String, Object>> chestLocations = new ArrayList<>();
                        for (Map.Entry<String, Float> e : locationCounts.entrySet()) {
                            Map<String, Object> loc = new LinkedHashMap<>();
                            loc.put("location", e.getKey());
                            loc.put("quantity", e.getValue());
                            chestLocations.add(loc);
                        }
                        itemEntry.put("chest_locations", chestLocations);
                    }
                    itemData.put(id.toString(), itemEntry);
                }
            }

            if (!itemData.isEmpty()) {
                // Add space_used calculation
                float spaceUsed = (totalSlots > 0) ? ((float) usedSlots / totalSlots) * 100f : 0f;
                itemData.put("space_used", String.format("%.0f%%", spaceUsed));

                categoryData.put(category, itemData);
            }
        }

        Map<String, Object> finalYaml = new LinkedHashMap<>();
        for (Map.Entry<String, Map<String, Object>> e : categoryData.entrySet()) {
            finalYaml.put(e.getKey(), e.getValue());
        }

        try {
            File file = new File(FabricLoader.getInstance().getConfigDir().toFile(), "sorter/sortdiag.yaml");
            file.getParentFile().mkdirs();

            DumperOptions options = new DumperOptions();
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
            options.setPrettyFlow(true);

            Yaml yaml = new Yaml(options);
            try (FileWriter writer = new FileWriter(file)) {
                yaml.dump(finalYaml, writer);
            }
        } catch (IOException e) {
            source.sendError(Text.literal("Failed to write sorter/sortdiag.yaml: " + e.getMessage()));
            return 0;
        }

        source.sendFeedback(() -> Text.literal("Sorter diagnostic written to sorter/sortdiag.yaml"), false);
        return 1;
    }

    private String formatStackCount(int rawCount, int maxStackSize) {
        double stacks = rawCount / (double) maxStackSize;
        return String.format("%.1fs", stacks);
    }

    private int parseStackCount(String formatted) {
        try {
            return (int) Math.round(Double.parseDouble(formatted.replace("s", "")) * 64); // assumes 64 max
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    private boolean isContainerItem(ItemStack stack) {
        Item item = stack.getItem();

        return (item == Items.BUNDLE && stack.get(DataComponentTypes.BUNDLE_CONTENTS) != null) ||
            (Block.getBlockFromItem(item) instanceof ShulkerBoxBlock &&
                stack.get(DataComponentTypes.CONTAINER) != null);
    }

    private int distributeToChests(ItemStack stack, List<ChestRef> chests) {
        int originalCount = stack.getCount();
        int toSort = originalCount;
        int maxStackSize = Math.min(stack.getMaxCount(), 64);

        for (ChestRef ref : chests) {
            Inventory inv = ref.inventory;

            // Merge into existing stacks
            for (int slot = 0; slot < inv.size() && toSort > 0; slot++) {
                ItemStack target = inv.getStack(slot);
                if (!target.isEmpty() && ItemStack.areItemsAndComponentsEqual(stack, target) && target.getCount() < target.getMaxCount()) {
                    int space = target.getMaxCount() - target.getCount();
                    int move = Math.min(space, toSort);
                    target.increment(move);
                    toSort -= move;
                }
            }

            // Fill empty slots
            for (int slot = 0; slot < inv.size() && toSort > 0; slot++) {
                if (inv.getStack(slot).isEmpty()) {
                    int move = Math.min(toSort, maxStackSize);
                    ItemStack toPut = stack.copy();
                    toPut.setCount(move);
                    inv.setStack(slot, toPut);
                    toSort -= move;
                }
            }

            if (toSort == 0) break;
        }

        return originalCount - toSort;
    }

    private boolean sortContainerItem(ItemStack containerStack, ServerWorld world, BlockPos referencePos, Set<String> overflowCategories) {
        boolean sortedAny = false;
        List<ItemStack> contents = new ArrayList<>();

        boolean isBundle = containerStack.isOf(Items.BUNDLE);
        var bundleComp = isBundle ? containerStack.get(DataComponentTypes.BUNDLE_CONTENTS) : null;
        var shulkerComp = containerStack.get(DataComponentTypes.CONTAINER);

        // Extract contents
        if (isBundle && bundleComp != null) {
            for (ItemStack inner : bundleComp.iterateCopy()) {
                if (!inner.isEmpty()) contents.add(inner);
            }
        } else if (shulkerComp != null) {
            DefaultedList<ItemStack> tempList = DefaultedList.ofSize(27, ItemStack.EMPTY);
            shulkerComp.copyTo(tempList);
            for (ItemStack inner : tempList) {
                if (!inner.isEmpty()) contents.add(inner);
            }
        }

        List<ItemStack> leftovers = new ArrayList<>();

        for (ItemStack inner : contents) {
            boolean innerSorted = false;

            if (isContainerItem(inner)) {
                innerSorted = sortContainerItem(inner, world, referencePos, overflowCategories);
            }

            Identifier id = Registries.ITEM.getId(inner.getItem());
            String category = itemCategoryMap.get(id);
            if (category == null) {
                leftovers.add(inner);
                continue;
            }

            List<ChestRef> chests = findCategoryChests(world, referencePos, category);
            if (chests.isEmpty()) {
                leftovers.add(inner);
                overflowCategories.add(category);
                continue;
            }

            int moved = distributeToChests(inner, chests);
            if (moved > 0) {
                inner.setCount(inner.getCount() - moved);
                sortedAny = true;
                if (!inner.isEmpty()) leftovers.add(inner);
            } else if (!innerSorted) {
                leftovers.add(inner);
                overflowCategories.add(category);
            }
        }

        // Restore leftovers to the container
        if (isBundle) {
            containerStack.set(DataComponentTypes.BUNDLE_CONTENTS,
                leftovers.isEmpty() ? new BundleContentsComponent(List.of()) : new BundleContentsComponent(leftovers));
        } else if (shulkerComp != null) {
            DefaultedList<ItemStack> restored = DefaultedList.ofSize(27, ItemStack.EMPTY);
            for (int i = 0; i < leftovers.size() && i < 27; i++) {
                restored.set(i, leftovers.get(i));
            }
            containerStack.set(DataComponentTypes.CONTAINER, ContainerComponent.fromStacks(restored));
        }

        // Move the container itself if it's now empty
        boolean isNowEmpty = leftovers.isEmpty();
        Identifier id = Registries.ITEM.getId(containerStack.getItem());
        String category = itemCategoryMap.get(id);

        if (category != null && isNowEmpty) {
            List<ChestRef> chests = findCategoryChests(world, referencePos, category);
            if (!chests.isEmpty()) {
                int moved = distributeToChests(containerStack, chests);
                if (moved > 0) {
                    containerStack.setCount(0);
                    sortedAny = true;
                } else {
                    overflowCategories.add(category);
                }
            } else {
                overflowCategories.add(category);
            }
        }

        return sortedAny;
    }

    private BlockPos getAttachedChestPos(BlockPos signPos, BlockState signState, ServerWorld world) {
        Direction attachedDirection = null;
        if (signState.contains(Properties.HORIZONTAL_FACING)) {
            attachedDirection = signState.get(Properties.HORIZONTAL_FACING).getOpposite();
        }
        if (attachedDirection != null) {
            BlockPos chestPos = signPos.offset(attachedDirection);
            BlockEntity be = world.getBlockEntity(chestPos);
            if (be instanceof ChestBlockEntity) {
                return chestPos;
            }
        }
        return null;
    }

    private List<ChestRef> collectChestStack(ServerWorld world, BlockPos startPos) {
        List<ChestRef> result = new ArrayList<>();
        BlockPos cur = startPos;

        while (true) {
            BlockEntity be = world.getBlockEntity(cur);
            if (!(be instanceof ChestBlockEntity)) {
                LOGGER.info("[cheststack] No chest at {}. Stopping.", cur);
                break;
            }

            BlockState state = world.getBlockState(cur);

            // Skip right half of double chests
            if (state.contains(Properties.CHEST_TYPE) && state.get(Properties.CHEST_TYPE) == ChestType.RIGHT) {
                LOGGER.info("[cheststack] Skipping right half of double chest at {}", cur);
            } else {
                Block block = state.getBlock();
                if (block instanceof ChestBlock chestBlock) {
                    Inventory inv = ChestBlock.getInventory(chestBlock, state, world, cur, true);
                    if (inv != null) {
                        result.add(new ChestRef(cur, inv));
                        LOGGER.info("[cheststack] Added chest at {}", cur);
                    }
                }
            }

            // Check for category sign attached to the next chest *below*
            BlockPos below = cur.down();
            BlockState belowState = world.getBlockState(below);
            if (!(world.getBlockEntity(below) instanceof ChestBlockEntity)) {
                LOGGER.info("[cheststack] Block below {} is not a chest. Done.", cur);
                break;
            }

            for (Direction dir : Direction.Type.HORIZONTAL) {
                BlockPos signPos = below.offset(dir);
                BlockState signState = world.getBlockState(signPos);

                if (signState.getBlock() instanceof WallSignBlock wallSign) {
                    Direction facing = signState.get(WallSignBlock.FACING);
                    // Only proceed if the sign is facing the chest
                    if (!signPos.offset(facing.getOpposite()).equals(below)) {
                        continue;
                    }

                    BlockEntity signBe = world.getBlockEntity(signPos);
                    if (signBe instanceof SignBlockEntity sign) {
                        for (Text line : sign.getFrontText().getMessages(false)) {
                            if (line != null) {
                                String text = line.getString().trim();
                                if (!text.isEmpty()) {
                                    LOGGER.info("[cheststack] Found sign near chest at {}: '{}'", below, text);
                                }
                                if (text.startsWith("[") && text.endsWith("]")) {
                                    LOGGER.info("[cheststack] Found category sign at {}. Stopping stack here.", signPos);
                                    Collections.reverse(result);
                                    return result;
                                }
                            }
                        }
                    }
                }
            }

            cur = below;
        }

        Collections.reverse(result);
        return result;
    }

    private List<ChestRef> findCategoryChests(ServerWorld world, BlockPos nearPos, String category) {
        SignBlockEntity targetSign = null;
        double minDist = Double.MAX_VALUE;

        int searchRadius = 64;
        BlockPos min = nearPos.add(-searchRadius, -searchRadius / 2, -searchRadius);
        BlockPos max = nearPos.add(searchRadius, searchRadius / 2, searchRadius);

        LOGGER.info("[findCategoryChests] Searching signs near {} for category '{}'", nearPos, category);

        for (BlockPos pos : BlockPos.iterate(min, max)) {
            BlockEntity be = world.getBlockEntity(pos);
            if (!(be instanceof SignBlockEntity sign)) continue;

            Text[] lines = sign.getFrontText().getMessages(false);
            boolean matched = false;

            for (Text line : lines) {
                if (line != null) {
                    String text = line.getString().trim().toLowerCase();
                    if (!text.isEmpty()) {
                        LOGGER.info("[findCategoryChests] Found sign at {} with line: '{}'", pos, text);

                        if (text.contains("[" + category + "]")) {
                            matched = true;
                            double distSq = pos.getSquaredDistance(nearPos.getX() + 0.5, nearPos.getY() + 0.5, nearPos.getZ() + 0.5);
                            LOGGER.info("[findCategoryChests] → Matches category '{}' (distSq={})", category, distSq);
                            if (distSq < minDist) {
                                minDist = distSq;
                                targetSign = sign;
                            }
                            break;
                        }
                    }
                }
            }

            if (!matched) {
                LOGGER.info("[findCategoryChests] Sign at {} does not match category '{}'", pos, category);
            }
        }

        if (targetSign == null) {
            LOGGER.info("[findCategoryChests] No matching sign found for category '{}'", category);
            return Collections.emptyList();
        }

        LOGGER.info("[findCategoryChests] Nearest matching sign is at {}", targetSign.getPos());

        BlockPos chestPos = getAttachedChestPos(targetSign.getPos(), targetSign.getCachedState(), world);
        if (chestPos == null) {
            LOGGER.info("[findCategoryChests] No chest attached to sign at {}", targetSign.getPos());
            return Collections.emptyList();
        }

        LOGGER.info("[findCategoryChests] Resolved chest position: {}", chestPos);

        List<ChestRef> stack = collectChestStack(world, chestPos);
        LOGGER.info("[findCategoryChests] Found {} chest(s) in the stack.", stack.size());

        return stack;
    }


    private boolean needsQuoting(String s) {
        return s.contains(":") || s.contains(" ") || s.contains("#") || s.contains(",");
    }

    private static class TempMarker {
        Entity entity;
        int ticksLeft;
        TempMarker(Entity e, int ticks) {
            this.entity = e;
            this.ticksLeft = ticks;
        }
    }

    private static class ChestInfo {
        BlockPos pos;
        int totalSlots;
        int usedSlots;
        Map<Identifier, Integer> itemCounts;
        ChestInfo(BlockPos pos, int totalSlots, int usedSlots, Map<Identifier, Integer> itemCounts) {
            this.pos = pos;
            this.totalSlots = totalSlots;
            this.usedSlots = usedSlots;
            this.itemCounts = itemCounts;
        }
    }

    private static class ChestRef {
        BlockPos pos;
        Inventory inventory;
        ChestRef(BlockPos pos, Inventory inv) {
            this.pos = pos;
            this.inventory = inv;
        }
    }

    private static class ItemSummary {
        int totalQuantity = 0;
        Map<BlockPos, Integer> chestSlots = new HashMap<>();

        void addChest(BlockPos pos, int count) {
            chestSlots.merge(pos, count, Integer::sum);
        }

        int totalSlots() {
            return (int) Math.ceil(totalQuantity / 64.0);
        }

        String formatStacks() {
            return String.format("%.1fs", totalQuantity / 64.0);
        }
    }

}
